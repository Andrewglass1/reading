# Chapter 14 - The Dream Language

## Summary
  
* 

## What Stood Out

* 

## Questions Unanswered

* 

## Objections

* 

## Takeaways

* 

# Chapter 14

**Summarize the chapter ( 1+ bullets )**

* Graham lists what the characteristics of a dream language are: simple, not
  verbose, libraries, open source, good community, quick to prototype, and lots
  of abstractions that make sense to hackers. It has a built in profiler and
  perhaps tells you when you are algorithms are not optimized. If the language
  lets you write inline code to optimize, even better.

**What was one idea the surprised or stood out to you? Why? ( 2-4 sentences )**

That profilers need to be built into the language. I was in the camp that
profilers are addons to a language. Yout always need a profiler, why not build
it into the language?

**What was a question that you saw as unanswered? ( 1-2 sentences )**

Does he consider Lisp to be a dream language? I half-expected him to say that
Lisp has almost all of these qualifications.

**Did you have any objections or disagreements? ( 1-2 sentences)**

Committees aren't always a bad thing. I think a lot of great software is
written in the open source community by committee. I think you just need to the
right people on the committee. I mean HTML 5 has a committee.

**What were your key take aways or things you want to remember? ( 1+ bullets )**

Coming from Java, writing short code that is quick to prototype is a must have
for a language. I have felt this before and now I understand why I felt that
way. I want to just hack on things quickly and not be bothered with all of
the mental startup cost.

Chapter 14 The Dream Language

1) Summarize the chapter ( 1+ bullets )

Of all tyrannies, a tyranny exercised for the good of it's victims may be the most oppressive. - C.S. Lewis
How do languages become popular? 20 is critical mass, but getting there is more difficult than 20-1000
Whether or not a language has to be good to be popular, it must be popular to be good
To become popular, a scripting language must be a scripting language of a popular system
Language implementations must be free, because companies pay for software but hackers don't
Programming languages must have a book, preferably from O'Reilly
Greater levels of abstraction mean fewer tokens and less typing. Hackers are lazy.
Hackability: you must be able to use the language to accomplish whatever you want
Assume your target user is a genius who will do things you can't anticipate
A good program language should let hackers do unsavory things
A language should be good for writing throw away programs
When people take on a project that is too big they get overwhelmed, the project gets bogged down or the result is sterile and wooden
A good language needs libraries, future languages may have libraries as well developed as the core itself (sound like ruby?)
When libraries get too big it may take longer to find the function you need than it does to write it yourself (unless it's on github)
As Knuth pointed out long ago, speed only matters in certain critical bottlenecks.
A good profiler may do more to improve speed than the compiler
Future languages should provide a way to see bottlenecks in the source, or notify the user at runtime
Many applications of the future will be IO bound
Languages need time; most hackers will wait to see if a language survives for a few years before considering it
The early adopter years are useful to flush out bugs
Organic growth seems to yield better technology and richer founders than the big bang method
Languages don't get redesigned often enough
Hope and worry drive work like two legs on a bicycle
Language design by committee is a bad idea
The Dream Language is not only open source, but open design
2) What was one idea the surprised or stood out to you? Why? ( 2-4 sentences )

Of all tyrannies, a tyranny exercised for the good of it's victims may be the most oppressive. - C.S. Lewis I would have assumed that all tyrannies claim to be exercised for the good of their victims, but I assume some particularly oppressive tyrants would be happy to voice their malicious intent.
3) What was a question that you saw as unanswered? ( 1-2 sentences )

In Hackability Graham suggests a good language will allow a hacker to do whatever they want; surely some constraints are necessary?

4) Did you have any objections or disagreements? ( 1-2 sentences)

When libraries get too big it may take longer to find the function you need than it does to write it yourself Even large libraries today are frequently stored online in very readable formats, so this is probably not the case anymore.
5) What were your key take aways or things you want to remember? ( 1+ bullets ) - Of all tyrannies, a tyranny exercised for the good of it's victims may be the most oppressive. - C.S. Lewis - Hope and worry drive work like two legs on a bicycle. The worry makes it good. - The Dream Language is not only open source, but open design

Chapter 14 - The Dream Language 1) - There are common qualities to any successful language, including succinctness, hackability, and libraries - Any new language should offer free implementation, a book, and something to hack - New languages take time to be adopted - Lays out the characteristics of a dream language 2) The idea that a language must encourage throwaway programs was interesting to me. I had never thought of that before, but it makes perfect sense that a great many projects start as whims, and only eventually evolve into full fledged software. Particularly in the "fail fast" environment of tech today, any language that does not allow fast prototyping is not going to work. 3) How much of the success of a language is determined by these characteristics, and how much is pure luck? It seems to me that many have tried to fulfill these standards, but only a few languages have risen to the top. 4) Paul argues that a good language needs to be part of a platform, and that you should not have to download it specifically. I disagree with this notion, as many people, including myself, have no problem configuring their environment to support a new language if they want to try it. 5) - There are common characteristics to any great language - Moving forward, the standards for any new language are going to be very high

Chapter 14
1. Notes

New languages can be created
Should listen to what hackers want to make sure it will get used.
Needs documentation to show how it works.
Must be free.
Brevity.
Let hackers get all up inside it.
Give it time to percolate and marinate into something people will find delicious.
Iterate. Make sure to listen to users to improve.
2. Surprising Factors

would be curious to see if this is used as an inspiration piece for people who create languages already.
3. What's unanswered?

Does it hold water? Is it possible to create this dream language?
4. Objections/Disagreements

Not enough knowledge in my aresnal to debate the validity of his argument.
5. Key takeaways

It takes a long time to get your language off the ground, so be patient and in the lag time make it better by listening to users.

Design and Research
1.  Libraries, efficiency, & time all add together to allow a programmer to focus on solely building the application they want to build and not worrying about the language underneath. They should spend no time programming things that could be used for another application and only what is specific to their current application.
2.  It makes sense to me that I shouldn't have to constantly rebuild the wheel. If you like at Rails a lot of things like authentication, forms, and the most basic parts of the language are either pre-written or have been done before with easy to find and use gems.
3.  What is the best way to choose what language is complete?
4.  I agree completely, and this is why I have fallen in love with Ruby. The pure amount of gems is astonishing and can help you achieve anything in seconds.
5.  "A programming language does need a good implementation of course, and this must be free. Companies will pay but hackers will not, and this is who you need to attract.

Chapter 14 - The Dream Language
Summary
the best kind of language offers maximum capabilities with libraries and abstractions that allow minimum effort, but where you can still get into the nitty gritty to change things.
Stood out
the way to make the first 20 (most important) hackers aware of a new language is to give them a program that they want written in a new language so that they get to use it. also it must have online documentation and a book
Question Unanswered
following with the theme of the book that lisp is the best language, why is it the best in comparison to its close counterparts?
Objections
rewriting functional code to make it better is not always optimal when you are trying to scale a business. yes it is great, but it might not be necessary when time is of the essence.
Takeaways
big systems start from throwaway (one purpose, quick to write) programs. write those and evolve them to bigger things instead of trying to tackle something huge. rely on libraries.
be optimistic about your ability to solve the problem and pessimistic about your current solution.

Chapter 14 - The Dream Language
1. Summarize the chapter ( 1+ bullets )

A program should be both cleanly designed yet flexible.
Libraries will be given the same amount of detail as the core language.
2. What was one idea the surprised or stood out to you? Why? ( 2-4 sentences )

Efficiency hasn't mattered much in end-user applications. This is surprising because I feel like we often develop for a least common denominator.

You can be building a language without really knowing it since languages don't start big.

3. What was a question that you saw as unanswered? ( 1-2 sentences )

In a language, isn't there a barrier to understanding where things have been made easier for the programmer?

Can open source create the dream language?

4. Did you have any objections or disagreements? ( 1-2 sentences)

Organic growth is better, but yet we focus on who gets VC funding, etc.

Open source will lead to the dream language, yet isn't the open source community sort of like a committee?

5. What were your key take aways or things you want to remember? ( 1+ bullets )

Programming languages are good only if hackers like them.
To become popular a programming language has to be the scripting language of a popular system.
For a language to be used by big systems it must work for throwaway programs.

14
Exploring what makes languages popular and desirable
A language has to be popular to be good. This is because languages evolve on the surface, though their core will always remain relatively unchanged.
Java is popular largely because of its backing from Sun. How does corporate influence play a role?
Is it still the case that the language has to be around for a couple of years before even experts adopt. It seems that folks on the cutting edge like using the breakthrough implementations (node, for example).
Expert hackers are a tiny minority, but their decisions will influence all programmers Hackers like succinctness. Succinctness comes from abstraction. A good language should be clean (small core of well understood operators) and dirty (the programmers can do what they want with it) Maintain healthy naivety (optimistic about solving the problem) and skepticism (what's the value of this solution?)
